1 - Diameter of Binary Tree

class Solution {
    private int height(TreeNode node , int[]diameter){
        if(node==null) return 0;
        int []left=new int[1];
        int []right=new int[1];
         left[0]=height(node.left,diameter);
         right[0]=height(node.right,diameter);
        diameter[0] =Math.max(diameter[0],left[0]+right[0]);
        return 1+Math.max(left[0],right[0]);

    }
    public int diameterOfBinaryTree(TreeNode root) {
        
        int []diameter=new int[1];
        height(root,diameter);
        return diameter[0];
    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

2-  Symmetric Tree

class Solution {
    private boolean check(TreeNode left,TreeNode right){
        if(left==null && right==null) return true;
        if(left==null || right==null) return false;
        if(left.val!=right.val) return false;
       return check(left.left,right.right) && check(left.right,right.left);
    }
    public boolean isSymmetric(TreeNode root) {
        if(root==null) return false;
        
        return check(root.left,root.right);
        
    }
}

-------------------------------------------------------------------------------------------------------------------------------------------------------------------

3-Zig Zag or Spiral Traversal

class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> ans=new ArrayList<>();
        boolean flag=true;
        Queue<TreeNode> q=new LinkedList<>();
        q.add(root);
        while(!q.isEmpty()){
            int size=q.size();
            List<Integer> row=new ArrayList<>(Collections.nCopies(size,0));
            for(int i=0;i<size;i++){
                TreeNode node=q.poll();
                int idx=flag?i:(size-1-i);
                row.set(idx,node.data);
                if(node.left!=null){
                    q.add(node.left);
                }
                if(node.right!=null){
                    q.add(node.right);
                }
            }
            flag=!flag;
            ans.add(row);
        }
        return ans;
    }
}
4- Search in Rotated Sorted Array

class Solution {
    public int search(int[] arr, int target) {
       // int idx=-1;
        int s=0;
        int l=arr.length-1;
        while(s<=l){
            int mid=l+(s-l)/2;
            if(arr[mid]==target) return mid;
            if(arr[s]<=arr[mid]){
                if(arr[s]<=target && target<arr[mid]){
                    l=mid-1;
                }else{
                    s=mid+1;
                }
            }else{
                if(arr[l]>=target && target>arr[mid]){
                    s=mid+1;
                }else{
                    l=mid-1;
                }
            }
        }
           return -1;
    }
}
5-  Search in Rotated Sorted Array II
class Solution {
    public boolean search(int[] arr, int target) {
        int s=0;
        int l=arr.length-1;
        while(s<=l){
            int mid=s+(l-s)/2;
          
            if(arr[mid]==target) return true;
               if(arr[s]==arr[mid] && arr[mid]==arr[l]){
                s++;
                l--;
            }
           else  if(arr[s]<=arr[mid]){
                if(arr[s]<=target && target<arr[mid]){
                    l=mid-1;
                }else{
                    s=mid+1;
                }
             }
                else{
                    if(arr[mid]<target && target<=arr[l]){
                        s=mid+1;
                    }else{
                        l=mid-1;
                    }
                }
            }
        
        
        return false;
        
    }
}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------

6-Print root to node path in BT

class Solution {
    private void Helper(TreeNode node,List<List<Integer>> ans,List<Integer> path){
        if(node==null){
            return;
        }
        path.add(node.data);
        if(node.left==null && node.right==null){
            ans.add(new ArrayList<>(path));
        }
        else{
            Helper(node.left,ans,path);
            Helper(node.right,ans,path);
        }
        path.remove(path.size()-1);
    }
    public List<List<Integer>> allRootToLeaf(TreeNode root) {
        //your code goes here
        
        List<List<Integer>> ans=new ArrayList<>();
        if(root==null){
            return ans;
        }
        List<Integer> path=new ArrayList<>();
        Helper(root,ans,path);
        return ans;
    }
}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
7-Maximum Points You Can Obtain from Cards

class Solution {
    public int maxScore(int[] arr, int k) {
      int lsum=0;
      int rsum=0;
      int maxsum=0;
      int idx=arr.length-1;
      for(int i=0;i<k;i++){
        lsum+=arr[i];
        maxsum=lsum;
      }
      for(int i=k-1;i>=0;i--){
        lsum-=arr[i];
        rsum+=arr[idx];
        idx--;
        maxsum=Math.max(maxsum,lsum+rsum);
        
      }
      return maxsum;
        //your code goes here
    }
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
8- Count Complete Tree Nodes

class Solution {
  
    public int countNodes(TreeNode root) {
        //your code goes here
        int count=0;
        if(root==null){
          return 0;
        }
        count+=countNodes(root.left);
        count+=countNodes(root.right);
        return count+1;
     
    }
}
