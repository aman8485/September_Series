1 - Diameter of Binary Tree

class Solution {
    private int height(TreeNode node , int[]diameter){
        if(node==null) return 0;
        int []left=new int[1];
        int []right=new int[1];
         left[0]=height(node.left,diameter);
         right[0]=height(node.right,diameter);
        diameter[0] =Math.max(diameter[0],left[0]+right[0]);
        return 1+Math.max(left[0],right[0]);

    }
    public int diameterOfBinaryTree(TreeNode root) {
        
        int []diameter=new int[1];
        height(root,diameter);
        return diameter[0];
    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

2-  Symmetric Tree

class Solution {
    private boolean check(TreeNode left,TreeNode right){
        if(left==null && right==null) return true;
        if(left==null || right==null) return false;
        if(left.val!=right.val) return false;
       return check(left.left,right.right) && check(left.right,right.left);
    }
    public boolean isSymmetric(TreeNode root) {
        if(root==null) return false;
        
        return check(root.left,root.right);
        
    }
}

-------------------------------------------------------------------------------------------------------------------------------------------------------------------

3-Zig Zag or Spiral Traversal

class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> ans=new ArrayList<>();
        boolean flag=true;
        Queue<TreeNode> q=new LinkedList<>();
        q.add(root);
        while(!q.isEmpty()){
            int size=q.size();
            List<Integer> row=new ArrayList<>(Collections.nCopies(size,0));
            for(int i=0;i<size;i++){
                TreeNode node=q.poll();
                int idx=flag?i:(size-1-i);
                row.set(idx,node.data);
                if(node.left!=null){
                    q.add(node.left);
                }
                if(node.right!=null){
                    q.add(node.right);
                }
            }
            flag=!flag;
            ans.add(row);
        }
        return ans;
    }
}
4- Search in Rotated Sorted Array

class Solution {
    public int search(int[] arr, int target) {
       // int idx=-1;
        int s=0;
        int l=arr.length-1;
        while(s<=l){
            int mid=l+(s-l)/2;
            if(arr[mid]==target) return mid;
            if(arr[s]<=arr[mid]){
                if(arr[s]<=target && target<arr[mid]){
                    l=mid-1;
                }else{
                    s=mid+1;
                }
            }else{
                if(arr[l]>=target && target>arr[mid]){
                    s=mid+1;
                }else{
                    l=mid-1;
                }
            }
        }
           return -1;
    }
}
5-  Search in Rotated Sorted Array II
class Solution {
    public boolean search(int[] arr, int target) {
        int s=0;
        int l=arr.length-1;
        while(s<=l){
            int mid=s+(l-s)/2;
          
            if(arr[mid]==target) return true;
               if(arr[s]==arr[mid] && arr[mid]==arr[l]){
                s++;
                l--;
            }
           else  if(arr[s]<=arr[mid]){
                if(arr[s]<=target && target<arr[mid]){
                    l=mid-1;
                }else{
                    s=mid+1;
                }
             }
                else{
                    if(arr[mid]<target && target<=arr[l]){
                        s=mid+1;
                    }else{
                        l=mid-1;
                    }
                }
            }
        
        
        return false;
        
    }
}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------

6-Print root to node path in BT

class Solution {
    private void Helper(TreeNode node,List<List<Integer>> ans,List<Integer> path){
        if(node==null){
            return;
        }
        path.add(node.data);
        if(node.left==null && node.right==null){
            ans.add(new ArrayList<>(path));
        }
        else{
            Helper(node.left,ans,path);
            Helper(node.right,ans,path);
        }
        path.remove(path.size()-1);
    }
    public List<List<Integer>> allRootToLeaf(TreeNode root) {
        //your code goes here
        
        List<List<Integer>> ans=new ArrayList<>();
        if(root==null){
            return ans;
        }
        List<Integer> path=new ArrayList<>();
        Helper(root,ans,path);
        return ans;
    }
}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
7-Maximum Points You Can Obtain from Cards

class Solution {
    public int maxScore(int[] arr, int k) {
      int lsum=0;
      int rsum=0;
      int maxsum=0;
      int idx=arr.length-1;
      for(int i=0;i<k;i++){
        lsum+=arr[i];
        maxsum=lsum;
      }
      for(int i=k-1;i>=0;i--){
        lsum-=arr[i];
        rsum+=arr[idx];
        idx--;
        maxsum=Math.max(maxsum,lsum+rsum);
        
      }
      return maxsum;
        //your code goes here
    }
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
8- Count Complete Tree Nodes

class Solution {
  
    public int countNodes(TreeNode root) {
        //your code goes here
        int count=0;
        if(root==null){
          return 0;
        }
        count+=countNodes(root.left);
        count+=countNodes(root.right);
        return count+1;
     
    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
9- Find Peak Element
class Solution {
    public int findPeakElement(int[] arr) {
        int s=0;
        int l=arr.length-1;
        while(s<l){
            int mid=s+(l-s)/2;
            if(arr[mid]<arr[mid+1]){
                s=mid+1;
            }else{
                l=mid;
            }
        }
        return s;
    }
}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
10- Search in BST
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        while(root!=null){
            if(root.val==val){
                return root;
            }else if(val<root.val){
                root=root.left;
            }else{
                root=root.right;
            }
        }
        return null;
    }
}
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
11- Insert a given node in BST

class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        //your code goes here
        if(root==null){
           TreeNode node=new TreeNode(val);
           return node;
        }
        TreeNode curr=root;
        if(curr.data<val){
            curr.right=insertIntoBST(curr.right,val);
        }else{
            curr.left=insertIntoBST(curr.left,val);
        }
        return root;
        
    }
}

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
12-Validate Binary Search Tree

class Solution {
    public boolean isValidBST(TreeNode root) {
        return isValidBST(root,Long.MIN_VALUE,Long.MAX_VALUE);
        
    }
    public boolean isValidBST(TreeNode node,long minval,long maxval){
        if(node==null){
            return true;
        }
        if( node.val<=minval ||node.val>=maxval ) return false;
        return isValidBST(node.left,minval,node.val) && isValidBST(node.right,node.val,maxval);
    }
}
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 13- Lowest Common Ancestor of a Binary Search Tree

class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root==null) return null;
                if(p.val<root.val && q.val<root.val){
            return lowestCommonAncestor(root.left,p,q);
        }else if(p.val>root.val && q.val>root.val){
            return lowestCommonAncestor(root.right,p,q);
        }
        return root;
    }
}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
14- Binary Search Tree Iterator

class BSTIterator {
    int cnt=0;
    ArrayList<Integer> ls=new ArrayList<>();
    private void inorder(TreeNode root,ArrayList<Integer> ls){
if(root==null) return;
inorder(root.left,ls);
ls.add(root.val);
inorder(root.right,ls);
    }

    public BSTIterator(TreeNode root) {
        inorder(root,ls);
    }
    
    public int next() {
       return ls.get(cnt++);
    }
    
    public boolean hasNext() {
        if(cnt==ls.size()){
            return false;
        }
        return true;
    }
}
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
15- Two sum in BST

class Solution {
    private void inorder(TreeNode root,ArrayList<Integer> ls){
        if(root==null) return;
        inorder(root.left,ls);
        ls.add(root.data);
        inorder(root.right,ls);
    }
    public boolean twoSumBST(TreeNode root, int k) {
        //your code goes here
       ArrayList<Integer> ls=new ArrayList<>();
       inorder(root,ls);
       int left=0;
       int right=ls.size()-1;
       while(left<right){
        if(ls.get(left)+ls.get(right)==k) return true;
        else if(ls.get(left)+ls.get(right)>k){
            right--;
        }else{
            left++;
        }
       }

return false;

    }
}
